/* 
 * Intersight REST API
 *
 * This is Intersight REST API 
 *
 * OpenAPI spec version: 1.0.9-228
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = intersight.Client.SwaggerDateConverter;

namespace intersight.Model
{
    /// <summary>
    /// Represents a node within a cluster of device connectors. A Device Registration may contain multiple ClusterMembers with each holding the connection details of the device connector as well as the nodes current leadership within the cluster. 
    /// </summary>
    [DataContract]
    public partial class AssetClusterMember :  IEquatable<AssetClusterMember>, IValidatableObject
    {
        /// <summary>
        /// The status of the persistent connection between the device connector and Intersight.  
        /// </summary>
        /// <value>The status of the persistent connection between the device connector and Intersight.  </value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ConnectionStatusEnum
        {
            
            /// <summary>
            /// Enum Empty for ""
            /// </summary>
            [EnumMember(Value = "")]
            Empty,
            
            /// <summary>
            /// Enum Connected for "Connected"
            /// </summary>
            [EnumMember(Value = "Connected")]
            Connected,
            
            /// <summary>
            /// Enum NotConnected for "NotConnected"
            /// </summary>
            [EnumMember(Value = "NotConnected")]
            NotConnected
        }

        /// <summary>
        /// The current leadershipstate of this member. Updated by the device connector on failover or leadership change. If a member is elected as Primary within the cluster this connection will be the same as the DeviceRegistration connection. E.g a message addressed to the DeviceRegistration will be forwarded to the ClusterMember connection.  
        /// </summary>
        /// <value>The current leadershipstate of this member. Updated by the device connector on failover or leadership change. If a member is elected as Primary within the cluster this connection will be the same as the DeviceRegistration connection. E.g a message addressed to the DeviceRegistration will be forwarded to the ClusterMember connection.  </value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum LeadershipEnum
        {
            
            /// <summary>
            /// Enum Unknown for "Unknown"
            /// </summary>
            [EnumMember(Value = "Unknown")]
            Unknown,
            
            /// <summary>
            /// Enum Primary for "Primary"
            /// </summary>
            [EnumMember(Value = "Primary")]
            Primary,
            
            /// <summary>
            /// Enum Secondary for "Secondary"
            /// </summary>
            [EnumMember(Value = "Secondary")]
            Secondary
        }

        /// <summary>
        /// The status of the persistent connection between the device connector and Intersight.  
        /// </summary>
        /// <value>The status of the persistent connection between the device connector and Intersight.  </value>
        [DataMember(Name="ConnectionStatus", EmitDefaultValue=false)]
        public ConnectionStatusEnum? ConnectionStatus { get; set; }
        /// <summary>
        /// The current leadershipstate of this member. Updated by the device connector on failover or leadership change. If a member is elected as Primary within the cluster this connection will be the same as the DeviceRegistration connection. E.g a message addressed to the DeviceRegistration will be forwarded to the ClusterMember connection.  
        /// </summary>
        /// <value>The current leadershipstate of this member. Updated by the device connector on failover or leadership change. If a member is elected as Primary within the cluster this connection will be the same as the DeviceRegistration connection. E.g a message addressed to the DeviceRegistration will be forwarded to the ClusterMember connection.  </value>
        [DataMember(Name="Leadership", EmitDefaultValue=false)]
        public LeadershipEnum? Leadership { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="AssetClusterMember" /> class.
        /// </summary>
        /// <param name="Ancestors">Ancestors is an array containing the MO references of the ancestors in the object containment hierarchy. .</param>
        /// <param name="Moid">A unique identifier of this Managed Object instance.  .</param>
        /// <param name="Owners">An array of owners which represent effective ownership of this object.   .</param>
        /// <param name="Parent">The direct ancestor of this managed object in the containment hierarchy. .</param>
        /// <param name="Tags">An array of tags, which allow to add key, value meta-data to managed objects.  .</param>
        /// <param name="VersionContext">The versioning info for this managed object   .</param>
        /// <param name="Device">Device.</param>
        public AssetClusterMember(List<MoBaseMoRef> Ancestors = default(List<MoBaseMoRef>), string Moid = default(string), List<string> Owners = default(List<string>), MoBaseMoRef Parent = default(MoBaseMoRef), List<MoTag> Tags = default(List<MoTag>), MoVersionContext VersionContext = default(MoVersionContext), AssetDeviceRegistrationRef Device = default(AssetDeviceRegistrationRef))
        {
            this.Ancestors = Ancestors;
            this.Moid = Moid;
            this.Owners = Owners;
            this.Parent = Parent;
            this.Tags = Tags;
            this.VersionContext = VersionContext;
            this.Device = Device;
        }
        
        /// <summary>
        /// The Account ID for this managed object.  
        /// </summary>
        /// <value>The Account ID for this managed object.  </value>
        [DataMember(Name="AccountMoid", EmitDefaultValue=false)]
        public string AccountMoid { get; private set; }

        /// <summary>
        /// Ancestors is an array containing the MO references of the ancestors in the object containment hierarchy. 
        /// </summary>
        /// <value>Ancestors is an array containing the MO references of the ancestors in the object containment hierarchy. </value>
        [DataMember(Name="Ancestors", EmitDefaultValue=false)]
        public List<MoBaseMoRef> Ancestors { get; set; }

        /// <summary>
        /// The time when this managed object was created.  
        /// </summary>
        /// <value>The time when this managed object was created.  </value>
        [DataMember(Name="CreateTime", EmitDefaultValue=false)]
        public DateTime? CreateTime { get; private set; }

        /// <summary>
        /// The time when this managed object was last modified.  
        /// </summary>
        /// <value>The time when this managed object was last modified.  </value>
        [DataMember(Name="ModTime", EmitDefaultValue=false)]
        public DateTime? ModTime { get; private set; }

        /// <summary>
        /// A unique identifier of this Managed Object instance.  
        /// </summary>
        /// <value>A unique identifier of this Managed Object instance.  </value>
        [DataMember(Name="Moid", EmitDefaultValue=false)]
        public string Moid { get; set; }

        /// <summary>
        /// The fully-qualified type of this managed object, e.g. the class name.  
        /// </summary>
        /// <value>The fully-qualified type of this managed object, e.g. the class name.  </value>
        [DataMember(Name="ObjectType", EmitDefaultValue=false)]
        public string ObjectType { get; private set; }

        /// <summary>
        /// An array of owners which represent effective ownership of this object.   
        /// </summary>
        /// <value>An array of owners which represent effective ownership of this object.   </value>
        [DataMember(Name="Owners", EmitDefaultValue=false)]
        public List<string> Owners { get; set; }

        /// <summary>
        /// The direct ancestor of this managed object in the containment hierarchy. 
        /// </summary>
        /// <value>The direct ancestor of this managed object in the containment hierarchy. </value>
        [DataMember(Name="Parent", EmitDefaultValue=false)]
        public MoBaseMoRef Parent { get; set; }

        /// <summary>
        /// An array of tags, which allow to add key, value meta-data to managed objects.  
        /// </summary>
        /// <value>An array of tags, which allow to add key, value meta-data to managed objects.  </value>
        [DataMember(Name="Tags", EmitDefaultValue=false)]
        public List<MoTag> Tags { get; set; }

        /// <summary>
        /// The versioning info for this managed object   
        /// </summary>
        /// <value>The versioning info for this managed object   </value>
        [DataMember(Name="VersionContext", EmitDefaultValue=false)]
        public MoVersionContext VersionContext { get; set; }

        /// <summary>
        /// The version of the connector api. Describes the capability of the connector&#39;s framework. If the version is lower than the current minimum supported version defined in the service managing the connection, the device connector will be connected with limited capabilities until the device connector is upgraded to a fully supported version. For example if a device connector that was released without delta inventory capabilities registers and connects to Intersight, inventory collection may be disabled until it has been upgraded. 
        /// </summary>
        /// <value>The version of the connector api. Describes the capability of the connector&#39;s framework. If the version is lower than the current minimum supported version defined in the service managing the connection, the device connector will be connected with limited capabilities until the device connector is upgraded to a fully supported version. For example if a device connector that was released without delta inventory capabilities registers and connects to Intersight, inventory collection may be disabled until it has been upgraded. </value>
        [DataMember(Name="ApiVersion", EmitDefaultValue=false)]
        public long? ApiVersion { get; private set; }

        /// <summary>
        /// The partition number corresponding to the instance of the Proxy App which is managing the web-socket to the device connector.  
        /// </summary>
        /// <value>The partition number corresponding to the instance of the Proxy App which is managing the web-socket to the device connector.  </value>
        [DataMember(Name="AppPartitionNumber", EmitDefaultValue=false)]
        public long? AppPartitionNumber { get; private set; }

        /// <summary>
        /// The unique identifier for the current connection. The identifier persists across network connectivity loss and is reset on device connector process restart or platform administrator toggle of the Intersight connectivity. The connectionId can be used by services that need to interact with stateful plugins running in the device connector process. For example if a service schedules an inventory in a devices job scheduler plugin at registration it is not necessary to reschedule the job if the device loses network connectivity due to an Intersight service upgrade or intermittent network issues in the devices datacenter.  
        /// </summary>
        /// <value>The unique identifier for the current connection. The identifier persists across network connectivity loss and is reset on device connector process restart or platform administrator toggle of the Intersight connectivity. The connectionId can be used by services that need to interact with stateful plugins running in the device connector process. For example if a service schedules an inventory in a devices job scheduler plugin at registration it is not necessary to reschedule the job if the device loses network connectivity due to an Intersight service upgrade or intermittent network issues in the devices datacenter.  </value>
        [DataMember(Name="ConnectionId", EmitDefaultValue=false)]
        public string ConnectionId { get; private set; }

        /// <summary>
        /// If &#39;connectionStatus&#39; is not equal to Connected, connectionReason provides further details about why the device is not connected with the cloud.  
        /// </summary>
        /// <value>If &#39;connectionStatus&#39; is not equal to Connected, connectionReason provides further details about why the device is not connected with the cloud.  </value>
        [DataMember(Name="ConnectionReason", EmitDefaultValue=false)]
        public string ConnectionReason { get; private set; }


        /// <summary>
        /// The last time at which the &#39;connectionStatus&#39; property value changed. If connectionStatus is Connected, this time can be interpreted as the starting time since which a persistent connection has been maintained between the cloud and device connector. If connectionStatus is NotConnected, this time can be interpreted as the last time the device connector was connected with the cloud.  
        /// </summary>
        /// <value>The last time at which the &#39;connectionStatus&#39; property value changed. If connectionStatus is Connected, this time can be interpreted as the starting time since which a persistent connection has been maintained between the cloud and device connector. If connectionStatus is NotConnected, this time can be interpreted as the last time the device connector was connected with the cloud.  </value>
        [DataMember(Name="ConnectionStatusLastChangeTime", EmitDefaultValue=false)]
        public DateTime? ConnectionStatusLastChangeTime { get; private set; }

        /// <summary>
        /// The version of the device connector running on the managed device.  
        /// </summary>
        /// <value>The version of the device connector running on the managed device.  </value>
        [DataMember(Name="ConnectorVersion", EmitDefaultValue=false)]
        public string ConnectorVersion { get; private set; }

        /// <summary>
        /// The IP Address of the managed device as seen from the cloud at the time of registration. Eg this could be the IP of the managed device&#39;s interface which has a route to the internet or a NAT IP when the managed device is deployed in a private network.  
        /// </summary>
        /// <value>The IP Address of the managed device as seen from the cloud at the time of registration. Eg this could be the IP of the managed device&#39;s interface which has a route to the internet or a NAT IP when the managed device is deployed in a private network.  </value>
        [DataMember(Name="DeviceExternalIpAddress", EmitDefaultValue=false)]
        public string DeviceExternalIpAddress { get; private set; }

        /// <summary>
        /// The name of the app which will proxy the messages to the device connector.   
        /// </summary>
        /// <value>The name of the app which will proxy the messages to the device connector.   </value>
        [DataMember(Name="ProxyApp", EmitDefaultValue=false)]
        public string ProxyApp { get; private set; }

        /// <summary>
        /// Gets or Sets Device
        /// </summary>
        [DataMember(Name="Device", EmitDefaultValue=false)]
        public AssetDeviceRegistrationRef Device { get; set; }


        /// <summary>
        /// The unique identity of the member within the cluster. The identity is retrieved from the platform and reported by the device connector at connection time.   
        /// </summary>
        /// <value>The unique identity of the member within the cluster. The identity is retrieved from the platform and reported by the device connector at connection time.   </value>
        [DataMember(Name="MemberIdentity", EmitDefaultValue=false)]
        public string MemberIdentity { get; private set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class AssetClusterMember {\n");
            sb.Append("  AccountMoid: ").Append(AccountMoid).Append("\n");
            sb.Append("  Ancestors: ").Append(Ancestors).Append("\n");
            sb.Append("  CreateTime: ").Append(CreateTime).Append("\n");
            sb.Append("  ModTime: ").Append(ModTime).Append("\n");
            sb.Append("  Moid: ").Append(Moid).Append("\n");
            sb.Append("  ObjectType: ").Append(ObjectType).Append("\n");
            sb.Append("  Owners: ").Append(Owners).Append("\n");
            sb.Append("  Parent: ").Append(Parent).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("  VersionContext: ").Append(VersionContext).Append("\n");
            sb.Append("  ApiVersion: ").Append(ApiVersion).Append("\n");
            sb.Append("  AppPartitionNumber: ").Append(AppPartitionNumber).Append("\n");
            sb.Append("  ConnectionId: ").Append(ConnectionId).Append("\n");
            sb.Append("  ConnectionReason: ").Append(ConnectionReason).Append("\n");
            sb.Append("  ConnectionStatus: ").Append(ConnectionStatus).Append("\n");
            sb.Append("  ConnectionStatusLastChangeTime: ").Append(ConnectionStatusLastChangeTime).Append("\n");
            sb.Append("  ConnectorVersion: ").Append(ConnectorVersion).Append("\n");
            sb.Append("  DeviceExternalIpAddress: ").Append(DeviceExternalIpAddress).Append("\n");
            sb.Append("  ProxyApp: ").Append(ProxyApp).Append("\n");
            sb.Append("  Device: ").Append(Device).Append("\n");
            sb.Append("  Leadership: ").Append(Leadership).Append("\n");
            sb.Append("  MemberIdentity: ").Append(MemberIdentity).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as AssetClusterMember);
        }

        /// <summary>
        /// Returns true if AssetClusterMember instances are equal
        /// </summary>
        /// <param name="other">Instance of AssetClusterMember to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AssetClusterMember other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.AccountMoid == other.AccountMoid ||
                    this.AccountMoid != null &&
                    this.AccountMoid.Equals(other.AccountMoid)
                ) && 
                (
                    this.Ancestors == other.Ancestors ||
                    this.Ancestors != null &&
                    this.Ancestors.SequenceEqual(other.Ancestors)
                ) && 
                (
                    this.CreateTime == other.CreateTime ||
                    this.CreateTime != null &&
                    this.CreateTime.Equals(other.CreateTime)
                ) && 
                (
                    this.ModTime == other.ModTime ||
                    this.ModTime != null &&
                    this.ModTime.Equals(other.ModTime)
                ) && 
                (
                    this.Moid == other.Moid ||
                    this.Moid != null &&
                    this.Moid.Equals(other.Moid)
                ) && 
                (
                    this.ObjectType == other.ObjectType ||
                    this.ObjectType != null &&
                    this.ObjectType.Equals(other.ObjectType)
                ) && 
                (
                    this.Owners == other.Owners ||
                    this.Owners != null &&
                    this.Owners.SequenceEqual(other.Owners)
                ) && 
                (
                    this.Parent == other.Parent ||
                    this.Parent != null &&
                    this.Parent.Equals(other.Parent)
                ) && 
                (
                    this.Tags == other.Tags ||
                    this.Tags != null &&
                    this.Tags.SequenceEqual(other.Tags)
                ) && 
                (
                    this.VersionContext == other.VersionContext ||
                    this.VersionContext != null &&
                    this.VersionContext.Equals(other.VersionContext)
                ) && 
                (
                    this.ApiVersion == other.ApiVersion ||
                    this.ApiVersion != null &&
                    this.ApiVersion.Equals(other.ApiVersion)
                ) && 
                (
                    this.AppPartitionNumber == other.AppPartitionNumber ||
                    this.AppPartitionNumber != null &&
                    this.AppPartitionNumber.Equals(other.AppPartitionNumber)
                ) && 
                (
                    this.ConnectionId == other.ConnectionId ||
                    this.ConnectionId != null &&
                    this.ConnectionId.Equals(other.ConnectionId)
                ) && 
                (
                    this.ConnectionReason == other.ConnectionReason ||
                    this.ConnectionReason != null &&
                    this.ConnectionReason.Equals(other.ConnectionReason)
                ) && 
                (
                    this.ConnectionStatus == other.ConnectionStatus ||
                    this.ConnectionStatus != null &&
                    this.ConnectionStatus.Equals(other.ConnectionStatus)
                ) && 
                (
                    this.ConnectionStatusLastChangeTime == other.ConnectionStatusLastChangeTime ||
                    this.ConnectionStatusLastChangeTime != null &&
                    this.ConnectionStatusLastChangeTime.Equals(other.ConnectionStatusLastChangeTime)
                ) && 
                (
                    this.ConnectorVersion == other.ConnectorVersion ||
                    this.ConnectorVersion != null &&
                    this.ConnectorVersion.Equals(other.ConnectorVersion)
                ) && 
                (
                    this.DeviceExternalIpAddress == other.DeviceExternalIpAddress ||
                    this.DeviceExternalIpAddress != null &&
                    this.DeviceExternalIpAddress.Equals(other.DeviceExternalIpAddress)
                ) && 
                (
                    this.ProxyApp == other.ProxyApp ||
                    this.ProxyApp != null &&
                    this.ProxyApp.Equals(other.ProxyApp)
                ) && 
                (
                    this.Device == other.Device ||
                    this.Device != null &&
                    this.Device.Equals(other.Device)
                ) && 
                (
                    this.Leadership == other.Leadership ||
                    this.Leadership != null &&
                    this.Leadership.Equals(other.Leadership)
                ) && 
                (
                    this.MemberIdentity == other.MemberIdentity ||
                    this.MemberIdentity != null &&
                    this.MemberIdentity.Equals(other.MemberIdentity)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.AccountMoid != null)
                    hash = hash * 59 + this.AccountMoid.GetHashCode();
                if (this.Ancestors != null)
                    hash = hash * 59 + this.Ancestors.GetHashCode();
                if (this.CreateTime != null)
                    hash = hash * 59 + this.CreateTime.GetHashCode();
                if (this.ModTime != null)
                    hash = hash * 59 + this.ModTime.GetHashCode();
                if (this.Moid != null)
                    hash = hash * 59 + this.Moid.GetHashCode();
                if (this.ObjectType != null)
                    hash = hash * 59 + this.ObjectType.GetHashCode();
                if (this.Owners != null)
                    hash = hash * 59 + this.Owners.GetHashCode();
                if (this.Parent != null)
                    hash = hash * 59 + this.Parent.GetHashCode();
                if (this.Tags != null)
                    hash = hash * 59 + this.Tags.GetHashCode();
                if (this.VersionContext != null)
                    hash = hash * 59 + this.VersionContext.GetHashCode();
                if (this.ApiVersion != null)
                    hash = hash * 59 + this.ApiVersion.GetHashCode();
                if (this.AppPartitionNumber != null)
                    hash = hash * 59 + this.AppPartitionNumber.GetHashCode();
                if (this.ConnectionId != null)
                    hash = hash * 59 + this.ConnectionId.GetHashCode();
                if (this.ConnectionReason != null)
                    hash = hash * 59 + this.ConnectionReason.GetHashCode();
                if (this.ConnectionStatus != null)
                    hash = hash * 59 + this.ConnectionStatus.GetHashCode();
                if (this.ConnectionStatusLastChangeTime != null)
                    hash = hash * 59 + this.ConnectionStatusLastChangeTime.GetHashCode();
                if (this.ConnectorVersion != null)
                    hash = hash * 59 + this.ConnectorVersion.GetHashCode();
                if (this.DeviceExternalIpAddress != null)
                    hash = hash * 59 + this.DeviceExternalIpAddress.GetHashCode();
                if (this.ProxyApp != null)
                    hash = hash * 59 + this.ProxyApp.GetHashCode();
                if (this.Device != null)
                    hash = hash * 59 + this.Device.GetHashCode();
                if (this.Leadership != null)
                    hash = hash * 59 + this.Leadership.GetHashCode();
                if (this.MemberIdentity != null)
                    hash = hash * 59 + this.MemberIdentity.GetHashCode();
                return hash;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
